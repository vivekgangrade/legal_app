# 1. Introduction

## 1.1. Scope of the document
This document provides a comprehensive detailed design for the **Legal Case Management System**. It outlines the system architecture, component design, data models, and interface definitions required to build and maintain the application. The document serves as a reference for developers, testers, and stakeholders involved in the project.

## 1.2. Intended Audience
The intended audience for this document includes:
*   **Developers**: To understand the technical implementation details.
*   **System Architects**: To review the architectural decisions and patterns.
*   **Project Managers**: To gain an overview of the system components and progress.
*   **QA Engineers**: To understand the system flow for testing purposes.

## 1.3. System overview
The Legal Case Management System is a web-based application designed to help legal professionals manage their cases and clients efficiently. It features a modern **React-based frontend** for user interaction and a robust **FastAPI (Python) backend** for data processing and business logic. The system uses **PostgreSQL** as its persistent data store and is containerized using **Docker** for consistent deployment environments, with support for **Kubernetes** orchestration.

# 2. System Design

## 2.1. Application Design
The application follows a **Microservices-style Architecture** (or decoupled Client-Server architecture):
*   **Frontend**: A Single Page Application (SPA) built with **React** (Vite), **Tailwind CSS**, and **React Router**. It handles the presentation layer and user interactions.
*   **Backend**: A RESTful API built with **FastAPI**. It handles business logic, authentication, and database interactions.
*   **Database**: **PostgreSQL** relational database for storing persistent data.
*   **Infrastructure**: The system is containerized using **Docker** and orchestrated via **Docker Compose** (for development) and **Kubernetes** (for production).

```mermaid
graph TD
    User((User))
    subgraph "Frontend Container"
        UI[React App]
    end
    subgraph "Backend Container"
        API[FastAPI Server]
        Auth[Auth Handler]
        Router[Routers]
    end
    subgraph "Data Storage"
        DB[(PostgreSQL DB)]
    end

    User -->|HTTPS| UI
    UI -->|JSON/REST| API
    API -->|Route| Router
    Router -->|Verify| Auth
    Router -->|SQLAlchemy| DB
```

## 2.2. Process Flow
The typical process flow involves:
1.  **User Action**: The user interacts with the React Frontend (e.g., logging in, creating a case).
2.  **API Request**: The Frontend sends an HTTP/HTTPS request (GET, POST, PUT, DELETE) to the FastAPI Backend.
3.  **Authentication**: Requests are intercepted by middleware (e.g., CORS) and authenticated using JWT Bearer tokens (where applicable).
4.  **Business Logic**: The Backend processes the request using logic defined in Routers (`cases`, `users`).
5.  **Data Access**: The Backend interacts with the PostgreSQL database via SQLAlchemy ORM to CRUD (Create, Read, Update, Delete) data.
6.  **Response**: The Backend returns a JSON response to the Frontend.
7.  **UI Update**: The Frontend updates the UI based on the response.

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend (React)
    participant B as Backend (FastAPI)
    participant D as Database (PostgreSQL)

    U->>F: Performs Action (e.g., Login)
    F->>B: Send API Request (POST /token)
    note right of F: Include Credentials
    B->>D: Query User Data
    D-->>B: Return User Record
    B->>B: Verify Password
    alt Valid Credentials
        B-->>F: Return JWT Token
        F->>U: Show Dashboard
    else Invalid Credentials
        B-->>F: Return Error 401
        F->>U: Show Error Message
    end
```

## 2.3. Information Flow
Data flows primarily between the Client (Browser), the API Server, and the Database.
*   **Client -> Server**: JSON payloads containing user input (e.g., case details, login credentials).
*   **Server -> Database**: SQL queries generated by the ORM.
*   **Database -> Server**: Result sets (User records, Case records).
*   **Server -> Client**: JSON responses/pydantic models.

```mermaid
flowchart LR
    C(["Client Browser"])
    API(["FastAPI Server"])
    ORM(["SQLAlchemy ORM"])
    DB[("PostgreSQL")]

    C -- "JSON Request\n(HTTP/HTTPS)" --> API
    API -- "SQL Queries" --> ORM
    ORM -- "Query" --> DB
    DB -- "Result Sets" --> ORM
    ORM -- "ORM Objects" --> API
    API -- "JSON Response" --> C
```

## 2.4. Components Design
### Frontend Components
*   **App.jsx**: Main application entry point and routing configuration.
*   **Pages**: Individual views (e.g., Login, Dashboard, Case List, Case Detail).
*   **Components**: Reusable UI elements (e.g., Navbar, Forms, Modals).
*   **Services**: API integration layer (`axios` calls).

### Backend Components
*   **main.py**: Application entry point, lifespan management (startup/shutdown), and CORS configuration.
*   **routers/**:
    *   `users.py`: Handles user registration, login, and profile management.
    *   `cases.py`: Handles case creation, retrieval, updates, and deletion.
*   **models.py**: SQLAlchemy database models (`User`, `Case`).
*   **schemas.py**: Pydantic models for request/response validation.
*   **database.py**: Database connection handling and session management.

```mermaid
graph TD
    subgraph Frontend
        A[App.jsx / Router] --> P1[LoginPage]
        A --> P2[DashboardPage]
        A --> P3[CaseListPage]
        A --> P4[CaseDetailPage]
        P1 & P2 & P3 & P4 --> C1[Navbar]
        P1 & P3 & P4 --> C2[Forms / Modals]
        P2 & P3 & P4 --> SVC[services/api.js]
    end
    subgraph Backend
        M[main.py] --> R1[routers/users.py]
        M --> R2[routers/cases.py]
        R1 & R2 --> SCH[schemas.py]
        R1 & R2 --> MDL[models.py]
        R1 & R2 --> DB[database.py]
    end
    SVC -- "REST API" --> M
```

## 2.5. Key Design Considerations
*   **Scalability**: The decoupled architecture allowing backend and frontend to scale independently.
*   **Maintainability**: Use of standard frameworks (FastAPI, React) and clear folder structure.
*   **Portability**: Docker containerization ensures the app runs consistently across different environments.
*   **Type Safety**: Usage of Pydantic and type hinting in Python ensures data validation.

## 2.6. API Catalogue
The Backend exposes the following REST endpoints:

**Users** (`/users`):
*   `POST /`: Register a new user.
*   `POST /token`: Login and retrieve an access token.
*   `GET /me`: Get current user details.

**Cases** (`/cases`):
*   `GET /`: Retrieve all cases.
*   `POST /`: Create a new case.
*   `GET /{case_id}`: Retrieve a specific case.
*   `PUT /{case_id}`: Update a specific case.
*   `DELETE /{case_id}`: Delete a specific case.

**General**:
*   `GET /`: Root endpoint (Welcome message).
*   `GET /health`: Health check endpoint.

```mermaid
graph LR
    ROOT["/"]
    HEALTH["/health"]
    subgraph Users ["/users"]
        U1["POST /\nRegister User"]
        U2["POST /token\nLogin"]
        U3["GET /me\nCurrent User"]
    end
    subgraph Cases ["/cases"]
        C1["GET /\nList Cases"]
        C2["POST /\nCreate Case"]
        C3["GET /{id}\nGet Case"]
        C4["PUT /{id}\nUpdate Case"]
        C5["DELETE /{id}\nDelete Case"]
    end
    API[FastAPI] --> ROOT
    API --> HEALTH
    API --> Users
    API --> Cases
```

# 3. Data Design

## 3.1. Data Model
The database schema consists of the following key entities:

### User
*   **id** (Integer, PK): Unique identifier.
*   **username** (String, Unique): User login name.
*   **email** (String, Unique): User email address.
*   **full_name** (String): Full name of the user.
*   **password** (String): Hashed password.
*   **is_active** (Boolean): Account status.

### Case
*   **id** (Integer, PK): Unique identifier.
*   **title** (String): Title of the legal case.
*   **description** (String): Detailed description.
*   **client_name** (String): Name of the client associated with the case.
*   **status** (Enum): Status (OPEN, CLOSED, PENDING).
*   **created_at** (DateTime): Timestamp of creation.
*   **updated_at** (DateTime): Timestamp of last update.

```mermaid
erDiagram
    USER {
        int id PK
        string username
        string email
        string full_name
        string password
        boolean is_active
    }
    CASE {
        int id PK
        string title
        string description
        string client_name
        string status
        datetime created_at
        datetime updated_at
    }
    %% Relationship implied by code comments (Future implementation)
    USER ||--o{ CASE : manages
```

## 3.2. Data Access Mechanism
Data access is managed through **SQLAlchemy ORM**. The application uses a `SessionLocal` dependency (`get_db`) to manage database transactions. This ensures that database connections are opened and closed properly for each request.

```mermaid
sequenceDiagram
    participant Router as Router (Endpoint)
    participant Dep as get_db() Dependency
    participant Session as SQLAlchemy Session
    participant DB as PostgreSQL

    Router->>Dep: Request DB Session
    Dep->>Session: Open SessionLocal()
    Session-->>Dep: Session Object
    Dep-->>Router: yield db
    Router->>Session: db.query(...) / db.add()
    Session->>DB: Execute SQL
    DB-->>Session: Return Results
    Session-->>Router: ORM Objects
    Router->>Session: db.commit() / db.rollback()
    Note over Dep,Session: Finally block: db.close()
```

## 3.3. Data Retention Policies
*(Current Implementation defaults)*: Data is retained indefinitely unless manually deleted via the `DELETE` APIs.

## 3.4. Data Migration
Database schema creation is handled by `Base.metadata.create_all(bind=engine)` on application startup. For production, a migration tool like **Alembic** is recommended (though not currently implemented in the basic setup).

# 4. Interfaces
*   **User Interface (UI)**: Web-based GUI accessed via browser (default: `http://localhost:3000` or `http://localhost:5173`).
*   **Application Programming Interface (API)**: JSON REST API over HTTP (default: `http://localhost:8000`).
*   **Database Interface**: PostgreSQL connection via TCP/IP on port 5432 using the `psycopg2` driver.

```mermaid
graph TB
    Browser(["User Browser\n:3000 / :5173"])
    API(["FastAPI Backend\n:8000"])
    Adminer(["Adminer DB UI\n:8080"])
    DB[("PostgreSQL\n:5432")]

    Browser -- "HTTP (UI)" --> API
    Browser -- "HTTP (DB Admin)" --> Adminer
    API -- "TCP/IP psycopg2" --> DB
    Adminer -- "TCP/IP" --> DB
```

# 5. State and Session Management
*   **Backend**: The backend is stateless. Session management is handled via **JWT (JSON Web Tokens)** (Bearer Token) passed in the `Authorization` header.
*   **Frontend**: State is managed using React's internal state mechanism (`useState`, `useEffect`, `Context API`). Authentication tokens are typically stored in `localStorage` or `sessionStorage` (implementation specific) to persist login sessions.

```mermaid
sequenceDiagram
    participant U as User
    participant FE as Frontend
    participant BE as Backend

    U->>FE: Enter Credentials
    FE->>BE: POST /users/token
    BE-->>FE: { access_token, token_type }
    FE->>FE: Store token in localStorage
    Note over FE: All subsequent requests include token
    FE->>BE: GET /cases (Authorization: Bearer <token>)
    BE->>BE: Validate token (lookup user by token)
    BE-->>FE: Protected Data
    U->>FE: Logout
    FE->>FE: Remove token from localStorage
```

# 6. Caching
*   *(Current Implementation)*: No explicit caching layer (e.g., Redis) is currently implemented.
*   **Browser Caching**: Static assets (JS, CSS) served by the frontend can be cached by the browser.

# 7. Non-Functional Requirements

## 7.1. Security Aspects
*   **Authentication**: OAuth2-style password flow with Bearer tokens.
*   **Password Hashing**: Passwords should be hashed before storage (Implementation note: Code contains TODOs for full production hashing implementation).
*   **CORS**: Configured to restrict cross-origin requests to trusted domains (e.g., localhost).
*   **Container Security**: Running services in isolated Docker containers helps limit the blast radius of potential exploits.

```mermaid
flowchart TD
    REQ[Incoming Request] --> CORS{CORS Check}
    CORS -- Blocked Origin --> ERR1[403 Forbidden]
    CORS -- Allowed Origin --> AUTH{Requires Auth?}
    AUTH -- No --> HANDLER[Route Handler]
    AUTH -- Yes --> TOKEN{Valid Bearer Token?}
    TOKEN -- No --> ERR2[401 Unauthorized]
    TOKEN -- Yes --> HANDLER
    HANDLER --> VALIDATE{Validate Input}
    VALIDATE -- Invalid --> ERR3[422 Validation Error]
    VALIDATE -- Valid --> DB[(Database)]
    DB --> RESP[JSON Response]
```

## 7.2. Performance Aspects
*   **Async/Await**: FastAPI uses Python's `asyncio` for high-performance non-blocking I/O.
*   **Vite**: Uses ES modules for fast frontend development and optimized production builds.
*   **Database Indexing**: Primary keys and unique constraints are indexed for faster lookups.

```mermaid
graph LR
    subgraph Frontend
        VITE[Vite Build] --> BUNDLE[Optimized JS Bundle]
        BUNDLE --> NGINX[Nginx Static Server]
    end
    subgraph Backend
        UVICORN[Uvicorn ASGI]
        ASYNC[asyncio Event Loop]
        UVICORN --> ASYNC
    end
    subgraph Database
        PG[PostgreSQL]
        IDX[Indexed Columns\nPK, username, email]
        PG --> IDX
    end
    NGINX -- "API Calls" --> UVICORN
    ASYNC -- "ORM Queries" --> PG
```

# 8. References
*   [FastAPI Documentation](https://fastapi.tiangolo.com/)
*   [React Documentation](https://react.dev/)
*   [PostgreSQL Documentation](https://www.postgresql.org/docs/)
*   [Docker Documentation](https://docs.docker.com/)
*   [Kubernetes Documentation](https://kubernetes.io/docs/)
